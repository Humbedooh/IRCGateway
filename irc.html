<html>
    <head>
        <title>IRC Over WebSockets Example</title>
    <style>
    .black_overlay{

        position: absolute;
        top: 0%;
        left: 0%;
        width: 100%;
        height: 100%;
        background-color: black;
        z-index:1001;
        -moz-opacity: 0.8;
        opacity:.80;
        filter: alpha(opacity=80);
    }
    .white_content {

        position: absolute;
        top: 25%;
        left: 25%;
        width: 450px;
        height: 250px;
        padding: 16px;
        border: 8px solid orange;
        background-color: white;
        z-index:1002;
        overflow: auto;
    }
    
    .user_operator {
        background-image: url(/irc/user_operator.png);
        background-repeat: no-repeat;
        background-position: center left;
        padding-left: 30px;
        height: 26px;
        list-style: none;
    }
    
    .user_voiced {
        background-image: url(/irc/user_voiced.png);
        background-repeat: no-repeat;
        background-position: center left;
        padding-left: 30px;
        height: 26px;
        list-style: none;
    }
    
    .user_normal {
        background-image: url(/irc/user_normal.png);
        background-repeat: no-repeat;
        background-position: center left;
        padding-left: 30px;
        height: 26px;
        list-style: none;
    }
    
    .user_channel {
        background-image: url(/irc/channel.png);
        background-repeat: no-repeat;
        background-position: center left;
        padding-left: 30px;
        height: 26px;
        list-style: none;
    }
    
    .user_channel_selected {
        background-image: url(/irc/channel.png), linear-gradient(to bottom,  rgba(242,246,248,1) 0%,rgba(216,225,231,1) 50%,rgba(181,198,208,1) 51%,rgba(224,239,249,1) 100%); /* W3C */
        background-repeat: no-repeat;
        background-position: center left;
        padding-left: 30px;
        height: 26px;
        list-style: none;
    }
    
    .user_normal_selected {
        background-image: url(/irc/user_normal.png), linear-gradient(to bottom,  rgba(242,246,248,1) 0%,rgba(216,225,231,1) 50%,rgba(181,198,208,1) 51%,rgba(224,239,249,1) 100%); /* W3C */
        background-repeat: no-repeat;
        background-position: center left;
        padding-left: 30px;
        height: 26px;
        list-style: none;
    }
    
    #caption {
        background: #9dd53a; /* Old browsers */
        background: linear-gradient(to bottom,  #9dd53a 0%,#a1d54f 50%,#80c217 51%,#7cbc0a 100%); /* W3C */
        border: 1px solid #666;
        width: 100%;
        height: 40px;
        float: left;
        text-align: center;
        overflow: auto;
        clear: both;
    }
    
    #input {
        background: rgb(252,234,187); /* Old browsers */
        background: linear-gradient(to bottom,  rgba(252,234,187,1) 0%,rgba(252,205,77,1) 50%,rgba(248,181,0,1) 51%,rgba(251,223,147,1) 100%); /* W3C */
        border: 1px solid #666;
        width: 100%;
        height: 40px;
        float: left;
        text-align: center;
        clear: both;
    }
    
    #stats {
        width: 100%;
        height: 30px;
        float: left;
        text-align: center;
        clear: both;
    }
    
    #wrapper {
        width: 1200px;
        height: 530px;
        clear: both;
        border-radius: 4px;
        border: 1px solid #666;
        box-shadow: 4px 4px 2px #BBB;
        background: #ffffff; /* Old browsers */
        background: linear-gradient(to bottom,  #ffffff 0%,#f6f6f6 47%,#ededed 100%); /* W3C */
        resize: both;
        overflow: hidden;
    }
    
    #tips {
        width: 100px;
        height: 80px;
        clear: both;
        border-radius: 4px;
        border: 1px solid #666;
        box-shadow: 4px 4px 2px #BBB;
        background: #ffffff; /* Old browsers */
        background: linear-gradient(to bottom,  #ffffff 0%,#f6f6f6 47%,#ededed 100%); /* W3C */
        resize: both;
        overflow: hidden;
    }
    
    #channels {
        font-family: Helvetica, Verdana, sans-serif;
        font-size: 15px;
        overflow: auto;
        float: left;
        height: calc(100% - 112px);
        width: 200px;
        border: 1px solid #333;
    }
    
    #users {
        font-family: Helvetica, Verdana, sans-serif;
        font-size: 15px;
        overflow: auto;
        background: rgb(240,249,255); /* Old browsers */
        background: linear-gradient(to right,  rgba(240,249,255,1) 0%,rgba(203,235,255,1) 47%,rgba(161,219,255,1) 100%); /* W3C */
        float: left;
        height: calc(100% - 112px);
        width: 198px;
        border: 1px solid #333;
    }
    
    #messages {
        overflow-y: scroll;
        float: left;
        height: calc(100% - 112px);
        width: calc(100% - 405px);
        border: 1px solid #333;
    }
    
    #channels ul
        {
        margin: 0;
        padding: 0;
        list-style-type: none;
        }
    #users ul
        {
        margin: 0;
        padding: 0;
        list-style-type: none;
        }
    #caption h4 {
        margin: 0px;
        padding: 0px;
        font-size: 15px;
    }
</style>
    </head>
    <body>
    
<h2>IRC Over WebSockets with httpd + mod_lua</h2>
<p>Use /quit to exit the IRC session, use /join #chan or /part #chan to join/part a channel.</p>
<div id="wrapper">
<div id="caption"><h4>Welcome to IRC!</h4></div>

<div id="channels">
    
</div>

<div id="messages">
    
</div>

<div id="users">
    
</div>

<div id="input">
    <form id="cmd">
        <input type="text" onkeydown="keyHandler(this, event);" id="inputBox" name="line" style="margin-top: 5px; width: 90%; border: 2px solid #333;"/><br/>
    </form>
</div>

<div id="stats">
    
</div>

</div>

<textarea name="raw" id="raw" style="display: none; width: 500px; height: 100px;"></textarea>

    <div id="fade" class="black_overlay"></div>
    <div id="light" class="white_content">
        <form>
            <h3>Welcome to IRCGateway.com!</h3>
            <p>This is merely a test of the WebSocket features in the Apache HTTP Server, but you are free to use it for chatting on IRC.</p>
            <table border="0" style="border: none;">
                <tr>
                    <td>
                        <label for="server">Pick a server: </label>
                    </td>
                    <td>
                        <select name="server">
                            <option value="chat.freenode.net">Freenode</option>
                            <option value="irc.oftc.net">OFTC</option>
                        </select>
                    </td>
                </tr>
                <tr>
                    <td>
                        <label for="username">Pick a username: </label>
                    </td>
                    <td>
                        <input id="username" name="username" type="text" placeholder="Type a username here:" max="16"/>
                    </td>
                </tr>
                <tr>
                    <td colspan="2">
                        <input type="button" onClick="connectToIRC(this.form); document.getElementById('light').style.display='none';document.getElementById('fade').style.display='none';" value="Connect to IRC"/>
                    </td>
                </tr>
            </table>
        </form>
    

    <audio id="ping" src="/irc/ping.mp3" preload="auto"></audio>

<script language="javascript" type="text/javascript">

  var wsUri = "ws://www.example.com/irc.lua"; // EDIT THIS!
  var output;
  var pInput = "";
  var bSent = 0;
  var bReceived = 0;
  var bURL = "";
  var bSecs = 0;
  var channels = new Array();
  var channelPings = new Array();
  var channel;
  var channelLines = new Array();
  var channelUsers = new Array();
  var topics = new Array();
  var online = false;
  var username = "NoSuchUserNameYet";
  
  Date.prototype.format = function(format) //author: meizz
{
  var o = {
    "M+" : this.getMonth()+1, //month
    "d+" : this.getDate(),    //day
    "h+" : this.getHours(),   //hour
    "m+" : this.getMinutes(), //minute
    "s+" : this.getSeconds(), //second
    "q+" : Math.floor((this.getMonth()+3)/3),  //quarter
    "S" : this.getMilliseconds() //millisecond
  }

  if(/(y+)/.test(format)) format=format.replace(RegExp.$1,
    (this.getFullYear()+"").substr(4 - RegExp.$1.length));
  for(var k in o)if(new RegExp("("+ k +")").test(format))
    format = format.replace(RegExp.$1,
      RegExp.$1.length==1 ? o[k] :
        ("00"+ o[k]).substr((""+ o[k]).length));
  return format;
}

function noCaseSort(a, b) {
    if (a.class !== undefined) {
        if (a.class < b.class) return 1;
        else if (a.class > b.class) return -1;
        else {
            if (a['name'].toLowerCase() < b['name'].toLowerCase()) return -1;
            if (a['name'].toLowerCase() > b['name'].toLowerCase()) return 1;
            return 0;
        }
    }
    if (a.type !== undefined) {
        if (a.type < b.type) return 1;
        else if (a.type > b.type) return -1;
        else {
            if (a['name'].toLowerCase() < b['name'].toLowerCase()) return -1;
            if (a['name'].toLowerCase() > b['name'].toLowerCase()) return 1;
            return 0;
        }
    }
    else {
        if (a['name'].toLowerCase() < b['name'].toLowerCase()) return -1;
        if (a['name'].toLowerCase() > b['name'].toLowerCase()) return 1;
        return 0;
    }
  }

  
  function changeChannel(event) {
    if (event.target.innerHTML) {
        channelPings[channel] = 0;
        channel = event.target.innerHTML;
        channelPings[channel] = 0;
        
        // Update channels list if a PM is started
        var found = false;
        for (i in channels) {
            if (channels[i].name == channel) {
                found = true;
                break;
            }
        }
        if (!found) {
            channels.push({'name': channel, 'type': 1})
        }
        if (!channelLines[channel.toLowerCase()]) {
            channelLines[channel.toLowerCase()] = new Array();
        }
        
        // Update channels list
        updateChannels();
        document.getElementById('inputBox').focus();
    }
  }
  
  function updateChannels(noUpdate) {
    var clist = document.getElementById('channels');
    clist.innerHTML = "";
    var list = document.createElement('ul');
    
    
    // Update user list for current channel
    var ulist = document.getElementById('users');
    ulist.innerHTML = "";
    var userlist = document.createElement('ul');
    
        
    if (channel && channels.length > 0 && channelUsers[channel.toLowerCase()]) {
        channelUsers[channel.toLowerCase()].sort(noCaseSort);
        for (i in channelUsers[channel.toLowerCase()]) {
            var l = channelUsers[channel.toLowerCase()][i];
            var el = document.createElement('li');
            el.innerHTML = l.name;
            el.className = "user_normal";
            if (l.class == 2) {
                el.className = "user_operator";
            }
            if (l.class == 1) {
                el.className = "user_voiced";
            }
            el.style.cursor = "pointer";
            el.onclick = changeChannel;
            userlist.appendChild(el);
        }
    }
    if (channel) {
        var caption = document.getElementById('caption');
        var topic = topics[channel] ? topics[channel.toLowerCase()] : "No topic set";
        if (channel.match(/^#/)) {
            caption.innerHTML = "<h4>Speaking in " + channel + ": " + topic + "</h4>";
        }
        else {
            caption.innerHTML = "<h4>Private query with " + channel + ":</h4>";
        }
    }
    ulist.appendChild(userlist);
    
    channels.sort(noCaseSort);
    for (chan in channels) {
        if (!channelPings[channels[chan].name.toLowerCase()]) {
            channelPings[channels[chan].name.toLowerCase()] = 0;
        }
        var l = channels[chan];
        var el = document.createElement('li');
        el.innerHTML = l.name;
        el.style.cursor = "pointer";
        if (!channels[chan].name.match(/^#/)) {
            el.className = "user_normal";
        } else {
            el.className = "user_channel";
        }
        if (l.name == channel) {
            channelPings[l] = 0;
            el.className = el.className + "_selected";
        }
        else if (channelPings[l.name] == 1) {
            el.style.color = "blue";
        }
        else if (channelPings[l.name] == 2) {
            el.style.color = "orange";
            el.style['font-weight'] = 'bold';
        }
        
        list.appendChild(el);
        el.onclick = changeChannel;
    }
    clist.innerHTML = "";
    clist.appendChild(list);
    
    
    if (!noUpdate) {
        var html = document.getElementById('messages');
        html.innerHTML = "";
        if (channelLines[channel.toLowerCase()]) {
            html.innerHTML = channelLines[channel.toLowerCase()].join("<br/>\n") + "<br/>";
            html.scrollTop = html.scrollHeight;
        }
    }
    
    
    
  }

  function updateStats() {
    var stats = document.getElementById('stats');
    var diff = ((new Date()).getTime() - bSecs)/1000;
    var kbsent = Math.floor(bSent/1024);
    var kbrec = Math.floor(bReceived/1024);
    var kbsec = Math.floor((bSent+bReceived) / diff);
    stats.innerHTML = "<small><kbd>Connected to " + bURL + " (via " + wsUri + ") - sent: " + kbsent + "kb, received: " + kbrec + "kb (" + kbsec + " bytes/sec)</kbd></small>";
  }
  
  function connectToIRC(form)
  {
    websocket = new WebSocket(wsUri);
    websocket.onopen = function(evt) { onOpen(evt, form) };
    websocket.onclose = function(evt) { onClose(evt) };
    websocket.onmessage = function(evt) { onMessage(evt) };
    websocket.onerror = function(evt) { onError(evt) };
    bURL = form.server.value;
    bSent = 0;
    bReceived = 0;
    bSecs = (new Date()).getTime();
  }

  function onOpen(evt, form)
  {
    writeToScreen("CONNECTED TO " + wsUri);
    sendToSocket(form.server.value);
    sendToSocket(form.username.value);
  }

  function onClose(evt)
  {
    writeToScreen("DISCONNECTED");
    document.getElementById('light').style.display='block';
    document.getElementById('fade').style.display='block';
  }
  
  function sendToSocket(args) {
    websocket.send(args);
    bSent += args.length;
    updateStats();
  }

  function pingBack() {
    sendToSocket("                             ");
  }
  function toColor(num) {
    num >>>= 0;
    var b = num & 0xFF,
        g = (num & 0xFF00) >>> 8,
        r = (num & 0xFF0000) >>> 16,
        a = ( (num & 0xFF000000) >>> 24 ) / 255 ;
    return "rgba(" + [r, g, b, a].join(",") + ")";
}
var mIRC = new Array('white', 'black', 'navy', 'green', 'red', 'maroon', 'purple', 'orange', 'yellow', 'lime', 'teal', 'aqua', 'blue', 'pink', 'grey', 'silver');

function colorise(str, color) {
    color = mIRC[parseInt(color)];
    return "<span style='color: " + color + "';>";
}
function toURL(str, url) {
    return '<a href="' + url + '" target="_blank">' + url + '</a>';
}

  function pushToScreen(chan, type, sender, msg) {
    var now = new Date().format("<kbd>[hh:mm:ss]</kbd>");
    var fmsg = "";
    var colors = new Array('#e90d7f','#8e55e9', '#b30e0e', '#17b339', '#58afb3', '#9d54b3', '#b39775', '#3176b3', '#e90d7f', '#8e55e9', '#b30e0e');
    
    if (sender) {
        var color = 1;
        for (i in sender) {
            color = (color + sender.charCodeAt(i)) % colors.length;
        }
        sender = '&lt;<font color="' + colors[color] + '"><kbd>' + sender + "</kbd></font>&gt;";
    }
    if (msg.match(/^\x01?ACTION/)) {
        type = "ACTION";
        msg = msg.replace(/^\x01?ACTION\s/, "");
    }
    if (msg) {
        msg = msg.replace(/</, "&lt;");
        msg = msg.replace(/(([a-z]+):\/\/[\w\-_]+(\.[\w\-_]+)+([\w\-\.,@?^=%&amp;:/~\+#]*[\w\-\@?^=%&amp;/~\+#])?)/, toURL);
        msg = msg.replace(/\x03(\d+)/g, colorise);
        msg = msg.replace(/\x03/g, "</span>");
        msg = msg.replace(/\x02/g, "<span style='font-weight: bold;'>");
        msg = msg.replace(/\x1f/g, "<span style='text-decoration: underline;'>");
        msg = msg.replace(/\x0f/g, "</span>");
    }
    if (new RegExp("\\b" + username + "\\b", "g").test(msg)) {
        var ping = document.getElementById('ping');
        if (ping) {
            ping.play();
        }
        msg = "<span style='border: 1px dashed #E70; color: orange; font-weight: bold;'>" + msg + "</span>";
    }
    
    if (type == "NOTICE") {
        fmsg = '<div style="width: 85px; float: left;">'+now+'</div><div style=" float: left;width: 110px;">&nbsp;</div><div style="width: calc(100% - 210px);float: left;"><kbd><span style="color: blue;"> ' + msg + '</span></kbd></div>';
    }
    else if (type == "MISC") {
        fmsg = '<div style="width: 85px; float: left;">'+now+'</div><div style=" float: left;width: 110px;">&nbsp;</div><div style="width: calc(100% - 210px);float: left;"><kbd><span style="color: green;">' + msg + '</span></kbd></div>';
    }
    else if (type == "ACTION") {
        fmsg = '<div style="width: 85px; float: left;">'+now+'</div><div style=" float: left;width: 110px;"></div><div style="width: calc(100% - 210px);float: left;"><kbd><span style="color: teal;"><b><i>' + sender + ' ' + msg + '</i></b></span></kbd></div>';
    }
    else if (type == "PART") {
        fmsg = '<div style="width: 85px; float: left;">'+now+'</div><div style=" float: left;width: 110px;">&nbsp;</div><div style="width: calc(100% - 210px);float: left;"><kbd><span style="color: purple;">Left ' + msg + '</span></kbd></div>';
    }
    else if (type == "CHANMSG") {
        fmsg = '<div style="width: 85px; float: left;">'+now+'</div><div style=" float: left;width: 110px;">'+sender+'</div><div style="width: calc(100% - 210px);float: left;"><kbd><span style="color: black;">' + msg + '</span></kbd></div>';
    }
    else if (type == "PRIVMSG") {
        fmsg = '<div style="width: 85px; float: left;">'+now+'</div><div style=" float: left;width: 110px;">'+sender+'</div><div style="width: calc(100% - 210px);float: left;"><kbd><span style="color: red;">' + msg + '</span></kbd></div>';
    }
    fmsg = '<div style="float: left; clear: both; width: 100%;">' + fmsg + "</div>\n";
    if (!chan) {
        writeToScreen(fmsg);
    }
    else {
        if (chan == channel) { writeToScreen(fmsg); }
        channelLines[chan.toLowerCase()].push('<kbd>' + fmsg + '</kbd>');
    }
    
  }
  function onMessage(evt)
  {
    //writeToScreen('<span style="color: green;">Got ' + evt.data +'</span>');
    bReceived += evt.data.length;
    updateStats();
    if (!evt.data.match(/^(   |RECV   |PONG)/)) {
        document.getElementById('raw').value += evt.data + "\n";
    }
    
    var type, msg;
    var arr = evt.data.match(/^([A-Z]+) (.+)$/);
    if (arr) {
        type = arr[1];
        msg = arr[2];
    }
    if (evt.data == 'STARTPING') {
        online = true;
        setInterval(pingBack, 2000);
        return;
    }
    if (type && type == 'JOIN') {
        channel = msg;
        var found = false;
        for (i in channels) {
            if (channels[i].name.toLowerCase() == channel.toLowerCase()) {
                found = true;
                break;
            }
        }
        if (!found) {
            channels.push({'name': channel, 'type': 2});
        }
        updateChannels();
        if (!channelLines[channel.toLowerCase()]) {
            channelLines[channel.toLowerCase()] = new Array();
            channelUsers[channel.toLowerCase()] = channelUsers[channel.toLowerCase()] ? channelUsers[channel.toLowerCase()] : new Array();
            pushToScreen(channel, 'JOIN', null, channel);
        }
        channelUsers[channel.toLowerCase()] = new Array();
    }
    if (type && type == 'NICK') {
        username = msg;
    }
    if (type && type == 'PART') {
        var nchannels = new Array();
        for (chan in channels) {
            if (channels[chan].name.toLowerCase() != msg.toLowerCase()) {
                nchannels.push(channels[chan]);
            }
        }
        channels = nchannels;
        if (channels[0]) {
            channel = channels[0].name;
        }
        updateChannels();
        pushToScreen(null, 'PART', null, channel);
    }
    if (type && type == "NOTICE") {
        pushToScreen(null, 'NOTICE', null, msg);
    }
    if (type && type == "CHANMSG") {
        var chan, sender, text;
        var arr = msg.match(/^(\S+) (\S+) (.+)$/);
        chan = arr[1];
        sender = arr[2];
        text = arr[3];
        if (!channelLines[chan.toLowerCase()]) {
            channelLines[chan.toLowerCase()] = new Array();
            pushToScreen(chan, 'JOIN', null, channel);
        }
        pushToScreen(chan, 'CHANMSG', sender, text);
        if (channelPings[chan.toLowerCase()] == 0) {
            channelPings[chan.toLowerCase()] = 1;
        }
        if (new RegExp("\\b" + username + "\\b", "g").test(text)) {
            channelPings[chan.toLowerCase()] = 2;
        }
        updateChannels(true);
    }
    if (type && type == "PRIVMSG") {
        var chan, sender, text;
        var arr = msg.match(/^(\S+) (.+)$/);
        sender = arr[1];
        text = arr[2];
        var senderl = sender.toLowerCase();
        var found = false;
        for (i in channels) {
            if (channels[i].name.toLowerCase() == senderl) {
                found = true;
                channels[i].name = sender;
                break;
            }
        }
        if (!found) {
            channels.push({'name': sender, 'type': 1})
        }
        if (!channelLines[senderl]) {
            channelLines[senderl] = new Array();
        }
        pushToScreen(senderl, 'CHANMSG', sender, text);
        if (!channelPings[senderl] || channelPings[senderl] == 0) {
            channelPings[senderl] = 1;
        }
        if (new RegExp("\\b" + username + "\\b", "g").test(text)) {
            channelPings[senderl] = 2;
        }
        updateChannels(true);
    }
    if (type && type == "TO") {
        var recipient, text;
        var arr = msg.match(/^(\S+) (.+)$/);
        recipient = arr[1];
        text = arr[2];
        var found = false;
        recipient = recipient.toLowerCase()
        for (i in channels) {
            if (channels[i].name.toLowerCase() == recipient) {
                found = true;
                recipient = channels[i].name
                break;
            }
        }
        if (!found) {
            channels.push({'name': recipient, 'type': 1})
        }
        if (!channelLines[recipient.toLowerCase()]) {
            channelLines[recipient.toLowerCase()] = new Array();
        }
        pushToScreen(recipient, 'CHANMSG', username, text);
        if (!channelPings[recipient.toLowerCase()] || channelPings[recipient.toLowerCase()] == 0) {
            channelPings[recipient.toLowerCase()] = 1;
        }
        if (new RegExp("\\b" + username + "\\b", "g").test(text)) {
            channelPings[recipient.toLowerCase()] = 2;
        }
        updateChannels(true);
    }
    if (type && type == "CMD") {
        var arr = msg.match(/^(\S+) (\S+) (\S+)\s?(.*)$/);
        var cmd = arr[1];
        var chan = arr[2];
        var usr = arr[3];
        var params = arr[4];
        if (cmd == 'TOPIC') {
            params = params.replace(/^:/, "");
            pushToScreen(chan, 'MISC', null, usr + " changed the topic to: " + params);
            topics[chan.toLowerCase()] = params;
            updateChannels(true);
        }
        if (cmd == 'JOIN') {
            pushToScreen(chan, 'MISC', null, usr + " joined the channel.");
            if (usr != username) {
                channelUsers[chan.toLowerCase()].push({'name': usr, 'class': ''});
            }
            updateChannels(true);
        }
        if (cmd == 'PART') {
            params = params.replace(/^:/, "");
            pushToScreen(chan, 'MISC', null, usr + " left the channel (" + params + ").");
            for (i in channelUsers[chan.toLowerCase()]) {
                if (channelUsers[chan.toLowerCase()][i].name == usr) {
                    channelUsers[chan.toLowerCase()].splice(i, 1);
                    break;
                }
            }
            updateChannels(true);
        }
        if (cmd == 'NOTICE') {
            pushToScreen(channel, 'NOTICE', null, params);
        }
        if (cmd == 'MODE') {
            
            pushToScreen(chan, 'MISC', null, usr + " set mode " + params);
            var arr = params.match(/([+-])([vob]) (\S+)/);
            if (arr) {
                var add = arr[1];
                var mode = arr[2].toLowerCase();
                var usr = arr[3];
                var nmode = 0;
                if (add == '+') {
                    if (mode == 'v') {
                        nmode = 1;
                    }
                    if (mode == 'o') {
                        nmode = 2;
                    }
                }
                else {
                    nmode = 0;
                }
                for (i in channelUsers[chan.toLowerCase()]) {
                    if (channelUsers[chan.toLowerCase()][i].name == usr) {
                        channelUsers[chan.toLowerCase()][i].class = nmode;
                        break;
                    }
                }
            }
            
            updateChannels(true);
        }
        if (cmd == 'QUIT') {
            params = params.replace(/^:/, "");
            for (c in channels) {
                var chan = channels[c].name.toLowerCase();
                if (channelUsers[chan]) {
                    for (i in channelUsers[chan]) {
                        if (channelUsers[chan][i].name == usr) {
                            channelUsers[chan].splice(i, 1);
                            pushToScreen(chan, 'MISC', null, usr + " quit (" + params + ").");
                            break;
                        }
                    }
                }
            }
            updateChannels(true);
        }
        if (cmd == 'NICK') {
            params = params.replace(/^:/, "");
            if (usr == username) {
                username = params;
                pushToScreen(channel, 'MISC', null, "You are now known as " + params);
            }
            for (c in channels) {
                var cname = channels[c].name.toLowerCase();
                if (cname.match(/^#/)) {
                    for (i in channelUsers[cname]) {
                        if (channelUsers[cname][i].name == usr) {
                            channelUsers[cname][i].name = params;
                            if (params != username) {
                                pushToScreen(cname, 'MISC', null, usr + " changed name to " + params);
                            }
                        }
                    }
                } else {
                    if (cname == usr) {
                        channelLines[params.toLowerCase()] = channelLines[usr.toLowerCase()];
                    }
                }
                
            }
            updateChannels(true);
        }
    }
    if (type && type == "SRV") {
        var arr = msg.match(/(\S+) (\d+) (.+)$/);
        var srv = arr[1];
        var code = arr[2];
        var params = arr[3];
        if (code == '372') {
            params = params.replace(/^\s*\S+ :/, "");
            pushToScreen(null, 'NOTICE', null, params);
        }
        if (code == '433') {
            params = params.replace(/^\s*\S+ :/, "");
            pushToScreen(null, 'NOTICE', null, "Nickname already in use! Please use /nick [newnickname] to change to a different nick.");
        }
        if (code == '353') {
            var ulist = params.match(/(#\S+) :(.+)$/);
            var chan = ulist[1];
            var theList = ulist[2];
            var users = theList.split(/ /);
            
            for (i in users) {
                var uclass = 0;
                var arr = users[i].match(/^([@+])/);
                if (arr) {
                    uclass = (arr[1] == "@") ? 2 : 1;
                }
                var usr = users[i].replace(/^[@+]/, "");
                channelUsers[chan.toLowerCase()].push({'name': usr, 'class': uclass});
                
            }
            updateChannels(true);
        }
        if (code == "332") {
            var ulist = params.match(/(#\S+) :(.+)$/);
            var chan = ulist[1];
            var topic = ulist[2];
            topics[chan.toLowerCase()] = topic;
            updateChannels(true);
        }
    }
    //websocket.close();
  }

  function onError(evt)
  {
    pushToScreen('<span style="color: red;">ERROR:</span> ' + evt.data);
  }

  function doSend(message)
  {
    
    var tmpc = channel;
    if (!online) {
        sendToSocket(message);
        writeToScreen("SENT: (offline) " + message);
        return;
    }
    var passThrough = true;
    if (message.match(/^\//)) {
        var arr = message.match(/^\/([a-z]+)/i);
        if (arr) {
            var cmd = arr[1];
            if (cmd == 'me') {
                message = message.replace(/^\/me\s/i, "");
                message = "\x01" + "ACTION " + message + "\x01";
            }
            // CS and NS aliases
            else if (cmd == 'cs') {
                message = message.replace(/^\/cs\s/i, "");
                tmpc = "ChanServ";
            }
            else if (cmd == 'ns') {
                message = message.replace(/^\/ns\s/i, "");
                tmpc = "NickServ";
            }
            
            else if (cmd == 'raw') {
                document.getElementById('raw').style.display = "block";
                document.getElementById('raw').style.height = "100px";
                return;
            }
            else if (cmd == 'msg') {
                var arr = message.match(/^\/msg (\S+) (.+)$/);
                if (arr) {
                    message = message.replace(/^\/msg (\S+) /, "");
                    tmpc = arr[1];
                }
            }
            else {
                var arr = message.match(/^\/([a-zA-Z]+)\s?(.*)$/)
                if (arr) {
                    cmd = arr[1].toUpperCase();
                    var params = arr[2];
                    if (cmd == 'PART' && (!params || params == "")) {
                        params = tmpc;
                    }
                    sendToSocket(cmd + " " + params);
                }
                return;
            }
        }
    }
    message = "PRIVMSG " + tmpc + " :" + message;
    sendToSocket(message);
    //writeToScreen("SENT: " + message);
  }

  function writeToScreen(message)
  {
    var output = document.getElementById('messages');
    var pre = document.createElement("kbd");
    pre.style.wordWrap = "break-word";
    pre.innerHTML = message + "<br/>";
    output.appendChild(pre);
    output.scrollTop = output.scrollHeight;
  }

//  window.addEventListener("load", init, false);

  function processForm(e) {
    if (e.preventDefault) e.preventDefault();

    /* do what you want with the form */

    // You must return false to prevent the default form behavior
    return false;
}
var form = document.getElementById('cmd');
function processForm(e) {
    if (e.preventDefault) e.preventDefault();
    pInput = form.line.value;
    doSend(form.line.value);
    form.line.value = ""
    form.line.focus();
    return false;
}

if (form.attachEvent) {
    form.attachEvent("submit", processForm);
} else {
    form.addEventListener("submit", processForm);
}

function keyHandler(obj,e) {
        var TABKEY = 9;
        if(e.keyCode == TABKEY) {
            var lastWord = obj.value.match(/(\S+)$/);
            if (lastWord && channel && channelUsers[channel]) {
                var word = lastWord[1].toLowerCase();
                obj.value = obj.value.substring(0, obj.value.length - word.length);
                for (i in channelUsers[channel]) {
                    var usr = channelUsers[channel][i].name.toLowerCase();
                    if (usr.length >= word.length && usr.substring(0, word.length) == word) {
                        obj.value += channelUsers[channel][i].name;
                        break;
                    }
                }
            }
            if(e.preventDefault) {
                e.preventDefault();
            }
            return false;
        }
        // up key: show last message
        if(e.keyCode == 38) {
            obj.value = pInput;
        }
    }
    
updateChannels();
</script>
</body>
</html>
